import {
  o,
  r
} from "./chunk-JQABY6XU.js";
import {
  appendErrors
} from "./chunk-V4UMBVK3.js";
import "./chunk-Y5IW5QF7.js";
import "./chunk-UV5CTPV7.js";

// node_modules/@hookform/resolvers/joi/src/joi.ts
var parseErrorSchema = (error, validateAllFieldCriteria) => error.details.length ? error.details.reduce((previous, error2) => {
  const _path = error2.path.join(".");
  if (!previous[_path]) {
    previous[_path] = { message: error2.message, type: error2.type };
  }
  if (validateAllFieldCriteria) {
    const types = previous[_path].types;
    const messages = types && types[error2.type];
    previous[_path] = appendErrors(
      _path,
      validateAllFieldCriteria,
      previous,
      error2.type,
      messages ? [].concat(messages, error2.message) : error2.message
    );
  }
  return previous;
}, {}) : {};
var joiResolver = (schema, schemaOptions = {
  abortEarly: false
}, resolverOptions = {}) => async (values, context, options) => {
  const _schemaOptions = Object.assign({}, schemaOptions, {
    context
  });
  let result = {};
  if (resolverOptions.mode === "sync") {
    result = schema.validate(values, _schemaOptions);
  } else {
    try {
      result.value = await schema.validateAsync(values, _schemaOptions);
    } catch (e) {
      result.error = e;
    }
  }
  if (result.error) {
    return {
      values: {},
      errors: r(
        parseErrorSchema(
          result.error,
          !options.shouldUseNativeValidation && options.criteriaMode === "all"
        ),
        options
      )
    };
  }
  options.shouldUseNativeValidation && o({}, options);
  return {
    errors: {},
    values: result.value
  };
};
export {
  joiResolver
};
//# sourceMappingURL=@hookform_resolvers_joi_src_joi__js.js.map
